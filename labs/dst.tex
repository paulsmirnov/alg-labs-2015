%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zztaskgroup{DST}{Динамические строки}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В задаче предлагается написать указанную в варианте функцию для обработки строк,
отвечающую заданному прототипу (при этом в самой функции исходные строки-аргументы
запрещается менять). Требуется использовать эту функцию в тестовой программе,
которая должна в цикле читать строки с клавиатуры и выдавать ответ на экран до
тех пор, пока пользователь не введет пустую строку (строку нулевой длины). 
Заданную функцию можно и \textbf{нужно} разбивать на более мелкие и понятные
подфункции, обеспечивая читаемость сложного алгоритма.

В этом задании нельзя предполагать, что все вводимые строки имеют длину меньше
заранее оговоренной константы (пользователь всегда может ввести строку длиннее,
чем вы предполагаете). Для чтения строки и для результата надо использовать
динамический буфер и функции динамического распределения памяти (написать отдельную
функцию чтения строки заранее неизвестной длины \texttt{char* ReadLine(void)}).
Для чтения нельзя использовать опасную функцию \texttt{gets(s)},
как альтернатива есть \texttt{fgets()} или (более медленное) посимвольное чтение
через \texttt{getchar()}.

В некоторых задачах <<строки>> языка Си
могут содержать один или несколько символов \verb|'\n'|, то есть несколько
логческих строк текста (абзац). Такие абзацы необходимо читать, склеивая
прочитанные логические строки, пока пользователь не обозначит пустую логическую
строку (нулевой длины), написав функцию \texttt{char* ReadParagraph(void)}).

Буквами договоримся считать прописные и строчные латинские буквы 
A--Z и a--z, словами --- последовательность букв и цифр 0--9. Все остальные
символы в строке будем считать разделителями слов. Подстрокой будем называть
произвольную часть строки.

В учебных целях при решении задач данного раздела функций стандартной
библиотеки, упрощающих работу со строками и символами (напр. из 
\texttt{<string.h>}), следует избегать, реализуя необходимую
функциональность самостоятельно.

Примеры диалога программы и пользователя:

\begin{zzoutput}
  Задание \thezztaskgroup-1: Выбор слов
  Введите строку: \zzuser{Hello, world!}
  Результат     : Hello, world
  Введите строку: \zzuser{int main(int argc, char* argv[]);}
  Результат     : int, main, int, argc, char, argv
  Введите строку: \zzuser{ }
\end{zzoutput}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bigskip
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{zztask}[Выбор слов]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую слова исходной,
разделенные запятой и пробелом.

Прототип: \mintinline{c}|char* ExtractWords(char const* str);|
\end{zztask}

\begin{zztask}[Выбор уникальных слов]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую слова исходной без
повторений, разделенные запятой и пробелом.

Прототип: \mintinline{c}|char* UniqueWords(char const* str);|
\end{zztask}

\begin{zztask}[Выбор букв]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую буквы исходной (в том же
порядке), разделенные запятой и пробелом.

Прототип: \mintinline{c}|char* ExtractLetters(char const* str);|
\end{zztask}

\begin{zztask}[Выбор уникальных букв]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую буквы исходной без
повторений (в том же порядке), разделенные запятой и пробелом.

Прототип: \mintinline{c}|char* UniqueLetters(char const* str);|
\end{zztask}

\begin{zztask}[Поиск зеркальных подстрок]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую список без повторений всех
подстрок длиной больше одного символа, зеркальное отражение которых также
содержится в строке. Все разделители при этом следует игнорировать.

Прототип: \mintinline{c}|char* FindMirror(char const* str);|
\end{zztask}

\begin{zztask}[Упрощённый поиск по маске]
В рамках общего условия задачи написать функцию, которая по заданной строке
и строковой же <<маске>> создает в динамической памяти другую, содержащую список
всех слов исходной строки (через запятую), удовлетворяющих маске. Маска может
содержать буквы, цифры и ровно один знак \verb|'*'|, обозначающий совпадение с любой
последовательностью букв, в том числе и пустой (\verb|"c*p"| даёт совпадение с
\textit{cp, cap, clip, creep\dots}).

Прототип: \mintinline{c}|char* FindMaskWords(char const* str, char const* mask);|
\end{zztask}

\begin{zztask}[Поиск по маске]
В рамках общего условия задачи написать функцию, которая по заданной строке
и строковой же <<маске>> создает в динамической памяти другую, содержащую список
всех слов исходной строки (через запятую), удовлетворяющих маске. Маска может
содержать буквы, цифры и знаки \verb|'*'|, обозначающие совпадение с любой
последовательностью букв, в том числе и пустой (\verb|"c*p*"| даёт
\textit{cp, cap, clip, couple, champion\dots}).

Прототип: \mintinline{c}|char* FindMaskWords(char const* str, char const* mask);|
\end{zztask}

\begin{zztask}[Поиск цепочек]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую список новых слов (через
запятую), образованных по следующему правилу. Если одно слово исходной строки
заканчивается, а какое-то другое начинается с одинакового сочетания букв
(длины $> 1$), то эта пара образует новое слово результирующей строки
($\textit{table} + \textit{length} \rightarrow \textit{tablength}$).

Прототип: \mintinline{c}|char* FindChains(char const* str);|
\end{zztask}

\begin{zztask}[Школоло строки] \textbf{ПЛОХО ОПРЕДЕЛЁННАЯ ЗАДАЧА}
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую <<транслитерированную>>
строчку. В этой строке оригинальные русские буквы должны быть заменены на
школоло-последовательности ASCII символов, приблизительно похожих.

Пример:
\verb|AJIEIIIA| (<<Алёша>>), \verb|HAPyIIIuTEJIb 3AKOHA|
(<<нарушитель закона>>), \verb!>|<uBOTHOE! (<<животное>>).

Прототип: \mintinline{c}|char* ConvertShkololo(char const* str);|
\end{zztask}

\begin{zztask}[Транслитерация строк]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую транслитерированную
строчку в соответствие со стандартами МИД РФ (\url{www.mid.ru}).
В этой строке оригинальные русские буквы должны быть заменены на
последовательности английских букв.

Пример:
\texttt{Alyosha} (<<Алёша>>), \texttt{narushitel{'} zakona}
(<<нарушитель закона>>), \texttt{zhivotnoye} (<<животное>>).

Прототип: \mintinline{c}|char* ConvertRussian(char const* str);|
\end{zztask}

\begin{zztask}[Перенос текста]
В рамках общего условия задачи написать функцию, которая по заданной строковой
переменной (возможно, содержащей несколько строк текста, разделенных символом
перевода строки \verb|'\n'|) создает в динамической памяти другую, содержащую
исходный текст, отформатированный в один абзац так, чтобы длина каждой
строки не превышала заданной ширины (вводится в начале тестовой программы).
Несколько подряд идущих пробелов следует заменять одним пробелом.
Короткие строки надо дополнять словами со следующей строки, а слишком
длинные слова переносить целиком на следующую.

Прототип: \mintinline{c}|char* FormatText(char const* str, int width);|
\end{zztask}

\begin{zztask}[Выравнивание текста]
В рамках общего условия задачи написать функцию, которая по заданной строковой
переменной (возможно, содержащей несколько строк текста, разделенных символом
перевода строки \verb|'\n'|) создает в динамической памяти другую, содержащую
исходный текст, отформатированный в один абзац так, чтобы длина каждой
строки была равна заданной ширине (вводится в начале тестовой программы).
Делать это надо за счет изменения числа подряд идущих пробелов. Слова
разбивать нельзя. Короткие строки надо дополнять словами со следующей
строки, а слишком длинные слова переносить целиком на следующую.

Прототип: \mintinline{c}|char* JustifyText(char const* str, int width);|
\end{zztask}
