%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zztaskgroup{SOR}{Сортировка массива}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В этой задаче требуется выделить в динамической области памяти 
(см. \texttt{malloc()}, \texttt{free()}) блок под 
массив из $N$ целых чисел ($N$ задается пользователем), заполнить массив
случайными числами от $1$ до $N$ включительно и вывести его на экран. Затем 
необходимо отсортировать (упорядочить по возрастанию) массив заданным методом 
и результат тоже вывести. Алгоритм сортировки реализовать в виде отдельной функции:\zztodo{Очень хорошая задача. Только мне казалось, что вы давали в прошлом семестре ее в более веселой формулировке. Хорошо бы сделать, чтобы у них еще замерялось время работы на случайном порядке(усредняя несколько) и в худшем случае. Еще хотелось бы, чтобы у них был не один алгоритм, а чтобы сравнивали несколько, можно исходную и модификацию, можно просто разные. Задачка станет довольно непростой, зато качественной. Может дать им какой-то шаблон для измерения времени или библу дать?}

\zzmintinline|void sort(int a[], int N);|

Подробности алгоритмов см. в дополнительной литературе.

\textbf{В 2014--2015 учебном году была другая (улучшенная) формулировка:}

Сравнение сортировок

На лекции изучаются разные алгоритмы сортировок, которые можно грубо разнести по группам:
%
\begin{enumerate}
\item простейшие (выбором, вставками, пузырьком, шейкером),
\item улучшенные (Шелла, прочёсыванием),
\item быстрые (слиянием, быстрая, кучей),
\item линейные (подсчётом, поразрядная, черпаком).
\end{enumerate}
%
Они отличаются вычислительной сложностью, да и просто временем работы. Более
того, у каждой сортировки могут быть разные реализации (модификации). В данной
задаче требуется сравнить среднее время работы различных сортировок для
массивов различной длины, на выбор (но не менее одной реализации одной
сортировки из каждой группы, можно по желанию включить и не перечисленные
выше). По результатам замеров времени работы сортировок требуется составить
таблицу со столбцами:

Размер массива	Время сортировки 1	Время сортировки 2	...	Время сортировки K

n1	t11	t12	...	t1k

Таблицу следует сохранить в CSV-файл (comma separated values) вида:

\begin{verbatim}
Size, Name1, Name2, ... , NameK
n1, t11, t12, ... , t1k
...
\end{verbatim}

и, открыв в Microsoft Excel, построить графики зависимости времени от размера массива (scatter plot, точечная диаграмма). Необходимо при этом убедиться в том, что полученные на практике результаты согласуются с теорией.

Комментарии:
%
\begin{itemize}
\item Размер массива следует менять от MIN\_SIZE до MAX\_SIZE с шагом SIZE\_STEP (например, от 1 до 100 с шагом 1 или от 10 до 10000 с шагом 10).
\item Следует задаться разумным числом повторов REPEAT\_COUNT для усреднения по разным случайным массивам (напр., 5, 10, или 100).
\item Для справедливого сравнения при фиксированном размере различные алгоритмы следует применять к массивам с одинаковым содержимым.
\item Во избежание копирования кода организовать цикл по сортировкам с использованием массива указателей на функции (или структур, их содержащих).
\end{itemize}

В конкретных вариантах, я думаю, надо давать модификации какой-то конкретной
сортировки, чтобы студенты увидели разницу, почувствовали ускорение от изменения алгоритма.

А старые тексты задач вот:

\begin{zztask}
В рамках общего условия задачи реализовать алгоритм 
сортировки выбором (selection sort). Он заключается в нахождении минимального элемента
в массиве и обмена его местами с самым первым элементом с продолжением сортировки оставшейся
части массива (начиная уже со второго элемента).
\end{zztask}

\begin{zztask}
В рамках общего условия задачи реализовать алгоритм 
сортировки пузырьком (bubble sort). Он заключается в последовательном (от начала к концу)
сравнении пар соседних элементов и обмена их местами, если они расположены 
не по возрастанию. Массив продолжает просматриваться снова и снова до 
тех пор, пока обмены элементов местами не прекратятся.
\end{zztask}

\begin{zztask}
В рамках общего условия задачи реализовать алгоритм 
сортировки шейкером (shaker sort). Это --- модификация алгоритма сортировки пузырьком,
при которой чередуются проходы по массиву от начала к концу и от конца к началу.
\end{zztask}

\begin{zztask}
В рамках общего условия задачи реализовать алгоритм 
сортировки вставками (insertion sort). На каждом шаге алгоритма выбирается следующий 
элемент из еще неотсортированной части массива и вставляется в подходящее место в уже 
отсортированной части в начале массива (путем сдвига элементов массива к концу).
\end{zztask}

\begin{zztask}
В рамках общего условия задачи реализовать алгоритм 
сортировки слиянием (merge sort). Этот алгортим основан на принципе
<<разделяй и властвуй>> и часто реализуется в виде рекурсивной функции:
отсортировать массив можно отсортировав его первую и вторую половину 
по-отдельности, а затем слив воедино две отсортированные части.
\end{zztask}

\begin{zztask}
В рамках общего условия задачи реализовать алгоритм 
<<быстрой>> сортировки (quick sort). Как и в сортировке слиянием алгоритм
рекурсивен, но массив бьется не пополам, а разделяется на две возможно 
неравные части так, что все элементы первой меньше элементов во второй.
\end{zztask}

\begin{zztask}
В рамках общего условия задачи реализовать алгоритм 
пирамидальной сортировки (с помощью кучи, heap sort). Основная идея ---
преобразовать массив в структуру данных <<куча>>, которая позволяет мгновенно 
находить самый большой элемент. Этот элемент меняется с последним элементом 
массива, размер кучи уменьшается на один и восстанавливается нарушенная 
структура кучи. Затем все повторяется.
\end{zztask}

\begin{zztask}
В рамках общего условия задачи реализовать алгоритм 
цифровой (поразрядной) сортировки (digital sort, radix sort). Основная идея ---
отсортировать числа по последней цифре с сохранением порядка чисел с одинаковыми 
цифрами и продолжить сортировку по большей цифре. Поскольку цифр очень мало (десять), 
то их сортировка производится методом подсчета.
\end{zztask}
