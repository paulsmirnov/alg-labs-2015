%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zztaskgroup{SOR}{Сортировка массива}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Задача сортировки (упорядочивания) массива решается далеко не единственным способом. Известно много
базовых схем, и в каждой из них возможны вариации, которые отличаются не только вычислительной
сложностью, но и просто временем работы~--- константами, зависящими от количества сравнений и
копирований элементов.

В данной работе требуется запрограммировать некоторый набор алгоритмов сортировки (вариаций) и
произвести их наглядное сравнение. Для этого необходимо измерить среднее время работы каждого
алгоритма на случайных массивах определённой длины. Из этих времён составить таблицу, показывающую
зависимость среднего времени работы каждого алгоритма от размера массива, а по таблице построить
графики в Excel. Первый столбец таблицы должен содержать размер массива, остальные~--- время работы,
по столбцу на алгоритм, столбцы должны быть озаглавлены. Таблица должна быть сохранена в обычный
текстовый файл формата CSV (Comma Separated Values), который в то же время легко открывается в
Excel.

Для соблюдения принципа модульности все сортировки должны быть оформлены в виде отдельной
библиотеки, а замер времени с созданием отчёта~--- в виде консольного приложения-профайлера. Чтобы
обеспечить лучшую взаимозаменяемость библиотек, в этой задаче будем использовать динамические
библиотеки (DLL на Windows, SO на Linux) с динамическим связыванием (действующие как <<плагины>>).
При таком подходе ваше приложение-профайлер будет работать с любой другой библиотекой сортировок и
наоборот.

Тестовое приложение не только занимается сбором статистики, но и проверяет правильность работы
вызываемых алгоритмов (в отладочной конфигурации). Для этого необходимо после каждой сортировки
сравнивать результат с эталонным, полученным при помощи библиотечной функции \texttt{qsort()}.

Ваша задача не просто реализовать заданные алгоритмы, но постараться сделать это наиболее быстрым
образом, оптимизируя вычисления. Возможно, стоит поискать и другие более быстрые модификации
алгоритмов, не указанные в задании.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zzsectionCOMMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\paragraph{Общность}
В библиотеке все алгоритмы должны быть реализованы в виде \texttt{static}-функций с одинаковым,
фиксированным для всех прототипом, соответствующим приведённому указателю на функцию:
%
\begin{minted}{c}
void (*sort_func_t)(int array[], int size);
\end{minted}

Динамическая библиотека должна экспортировать только одну функцию:
%
\begin{minted}{c}
__declspec(dllexport) sort_info_t* GetSortList(int* count);
\end{minted}
%
которая возвращает указатель на первый элемент массива и количество элементов в нём.
Каждый элемент этого массива соответствует одному реализованному алгоритму сортировки:

\begin{minted}{c}
// Описание одной вариации сортировки
typedef struct
{
  sort_func_t sort;             // Функция сортировки
  sort_family_t family;         // Базовое семейство
  sort_complexity_t complexity; // Вычислительная сложность
  char const* name;             // Имя, описывающее вариацию
} sort_info_t;

// Семейства сортировок
typedef enum
{
  // (Не определено)
  SORT_NA = -1,
  // Квадратичные
  SORT_SELECTION, SORT_INSERTION, SORT_BUBBLE,
  // Субквадратичные
  SORT_SHELL,
  // Квазилинейные
  SORT_COMB, SORT_MERGE, SORT_QUICK, SORT_HEAP,
  // Линейные
  SORT_COUNT, SORT_RADIX, SORT_BUCKET,
} sort_family_t;

// Вычислительная сложность
typedef enum
{
  SORT_QUADRATIC,
  SORT_SUBQUADRATIC,
  SORT_QUASILINEAR,
  SORT_LINEAR
} sort_complexity_t;
\end{minted}

В тестовом приложении вы будете использовать только поля \texttt{sort} и \texttt{name}, остальное
будет учитываться преподавателем при проверке.

\paragraph{Локализация}
Формат CSV в оригинальном своём исполнении, как это следует из названия, содержит ячейки таблицы,
разделённые запятыми. В русских настройках Excel запятая используется для разделения целой и дробной
части вещественных чисел, поэтому элементы строки таблицы разделяются точкой с запятой. Грамотно
воспользуйтесь \texttt{locale.h}, чтобы сохранить в файл нужные разделители.

\paragraph{Усреднение}
Обратите внимание, что нас интересует среднее время, т.е. необходимо усреднять по нескольким
случайным массивам одного размера (напр., \texttt{REPEAT\_COUNT} равный 5, 10, или 100). В то же
время для сравнения разных сортировок необходимо использовать одинаковые массивы. Вспомните, что
функция \texttt{rand()} генерирует последовательность псевдослучайных чисел, которая может быть
воспроизведена сколько угодно раз. Для сброса генератора в начало последовательности используется
функция \texttt{srand(r0)}.

\paragraph{Детализация}
Чтобы понять зависимость времени работы алгоритма от размера массива и получить плавный график,
нельзя ограничиваться одним, двумя, пятью значениями $N$. Размер массива следует менять от
\texttt{MIN\_SIZE} до \texttt{MAX\_SIZE} с шагом \texttt{SIZE\_STEP}, значения параметров подобрать
в зависимости от интересующего вас диапазона и от скорости работы алгоритма (например, от 1 до 100
с шагом 1, от 10 до 10000 с шагом 10 и т.п.).

\paragraph{Профилирование}
Мы хотим получить как можно более точное время работы алгоритма, поэтому при измерении времени
следует использовать подходящие функции стандартной библиотеки и операционной системы. При
недостаточной точности необходимо прибегнуть к дополнительным способам уменьшения погрешности
(повторное выполнение алгоритма). Разумеется, лишние отладочные проверки тоже не должны мешать
правильным измерениям, поэтому профилирование принято проводить не в отладочной, а в финальной
конфигурации проекта, с включенными оптимизациями компилятора.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zzsectionPLAN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Как полагается в разработке программного обеспечения, инструментарий определяется вариантами его
использования. Следовательно, начинать разработку следует с написания небольшого тестового
приложения.

\begin{enumerate}
\item Для начала создайте два проекта: один будет
собираться в динамическую библиотеку, другой --- в исполняемый файл. Проставьте зависимость второго
проекта от первого, чтобы изменения в библиотеке вели к её своевременной перекомпиляции во время
запуска тестового приложения.
%
\item Далее, в библиотеке добавьте заголовочный файл нужного формата и файл с исходным кодом, в
котором реализуйте функцию \texttt{GetSortList()} и добавьте одну функцию сортировки, имеющую
соответствующий прототип. Эта функция, например, может содержать вызов функции \texttt{qsort()}.
%
\item Далее, попробуйте загрузить библиотеку с помощью функции \texttt{LoadLibrary()} и после этого
воспользоваться функцией \texttt{GetProcAddress()} для доступа к адресу функции
\texttt{GetSortList()}. Убедитесь, что возвращаются корректные значения, функция вызывается и
возвращает то, что ожидается.
%
\item После этого, можно реализовать верификацию алгоритмов и измерение времени с учетом
комментариев выше. Начать рекомендуется с кода генерации случайных массивов. Затем стоит реализовать
последовательный вызов алгоритмов сортировки, полученных из \texttt{GetSortList()}, контролируя, что
в одном измерении алгоритмы запускаются на одних и тех же данных. Далее можно добавить проверку
того, что функция действительно сортирует введенный массив и завершить всё реализацией подсчета
времени и вывода таблицы.
%
\item В итоге, после того, как вы реализуете и протестируете весь сценарий использования, можно
будет очень легко добавлять новые алгоритмы, убеждаться в их корректности и производить замеры
времени.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zzsectionVARIATIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{zztask}[Выбором и пузырьком]
В рамках общего условия задачи реализовать алгоритмы сортировки:
\begin{enumerate}
\item Выбором (Selection sort)
  \begin{itemize}[--]
  \item со сдвигом (стабильная),
  \item с обменом,
  \item[$\star$] квадратичный выбор ($\sqrt N$ блоков по $\sqrt N$ элементов).
  \end{itemize}
\item Пузырьком (Bubble sort)
  \begin{itemize}[--]
  \item просто $N$ раз по $N$,
  \item остановка каждый раз на 1 раньше,
  \item остановка если не было обменов,
  \item шейкером (Cocktail sort),
  \item расчёской / гребнем (Comb sort) с фактором $2$ и $1.3$.
  \end{itemize}
\end{enumerate}
%
Рекомендованные источники:
Вирт~\cite[\S2.2.2--2.2.3]{wirth2016algoritmy},
Кнут~\cite[\S5.2.2--5.2.3]{knuth2014iskusstvo},
Макконнелл~\cite[\S3.2]{mcconnel2009analyz}.
\end{zztask}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{zztask}[Вставками]
В рамках общего условия задачи реализовать алгоритмы сортировки вставками (Insertion sort):
\begin{itemize}[--]
\item простые вставки с поиском слева направо,
\item простые вставки с поиском справа налево,
\item бинарные вставки,
\item попарные вставки с поиском сразу двух элементов,
\item[$\star$] двухпутевые вставки с дополнительной памятью.
\end{itemize}
%
Рекомендованные источники:
Вирт~\cite[\S2.2.1]{wirth2016algoritmy},
Кормен~\cite[\S1.1]{kormen2016algoritmy},
Кнут~\cite[\S5.2.1]{knuth2014iskusstvo},
Макконнелл~\cite[\S3.1]{mcconnel2009analyz}.
\end{zztask}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{zztask}[Шелла]
В рамках общего условия задачи реализовать алгоритмы сортировки Шелла (Shellsort) с убывающими шагами вида:
\begin{itemize}[--]
\item $\Delta_k = \left\lfloor\Delta_{k-1}/2\right\rfloor;\quad\Delta_0=N$,
\item $\Delta_k = \left\lfloor5\Delta_{k-1}/11\right\rfloor;\quad\Delta_0=N$,
\item $\Delta_k \in \{2^n-1\}_{n>0}$,
\item $\Delta_k \in \{4^n+3*2^{n-1}+1\}_{n>0}\cup{1}$,
\item $\Delta_k \in \{2^n \cdot 3^m\}_{n,m>0}$,
\item эмпирическая $\dots,701,301,132,57,23,10,4,1$ начинающаяся как $\Delta_{k-1} = 2.25\Delta_{k}$
\end{itemize}
%
Рекомендованные источники:
Вирт~\cite[\S2.3.1]{wirth2016algoritmy},
Кнут~\cite[\S5.2.1]{knuth2014iskusstvo},
Макконнелл~\cite[\S3.3]{mcconnel2009analyz}.
\end{zztask}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{zztask}[Слиянием]
В рамках общего условия задачи реализовать алгоритмы сортировки слиянием (Merge sort):
\begin{itemize}[--]
\item сверху вниз,
\item снизу вверх,
\item естественная,
\item разбиение на три части,
\item[$\star$] без дополнительной памяти.
\end{itemize}
%
Рекомендованные источники:
Вирт~\cite[\S2.4.1--2.4.3]{wirth2016algoritmy},
Кормен~\cite[\S1.3]{kormen2016algoritmy},
Кнут~\cite[\S5.2.4]{knuth2014iskusstvo},
Макконнелл~\cite[\S3.6]{mcconnel2009analyz}.
\end{zztask}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{zztask}[Быстрая и кучей]
В рамках общего условия задачи реализовать алгоритмы сортировки:
\begin{enumerate}
\item Быстрая (Quicksort)
  \begin{itemize}[--]
  \item перекидывая слева направо (Ломуто),
  \item классическое разбиение с двух концов (Хоара),
  \item при маленьком размере просто останавливаться, потом целиком вставками,
  \item выбор pivot случайный,
  \item выбор pivot как медианы из трех.
  \end{itemize}
\item Пирамидальная / кучей (Heapsort)
  \begin{itemize}[--]
  \item просеивание сверху вниз,
  \item только с одним сравнением в узле (<<снизу вверх>>).
  \end{itemize}
\end{enumerate}
%
Рекомендованные источники:
Вирт~\cite[\S2.3.2--2.3.3]{wirth2016algoritmy},
Кормен~\cite[\S7.1--7.5, \S8.1--8.4]{kormen2016algoritmy},
Кнут~\cite[\S5.2.2--5.2.3]{knuth2014iskusstvo},
Макконнелл~\cite[\S3.5, \S3.7]{mcconnel2009analyz}.
\end{zztask}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{zztask}[Линейные]
В рамках общего условия задачи реализовать алгоритмы сортировки:
\begin{enumerate}
\item Цифровая (Radix sort)
  \begin{itemize}[--]
  \item десятичная система,
  \item двоичная система,
  \item байтовая вариация (по основанию 256).
  \end{itemize}
\item Черпаком (Bucket sort).
\end{enumerate}
%
Рекомендованные источники:
Кормен~\cite[\S9.2--9.4]{kormen2016algoritmy},
Кнут~\cite[\S5.2.5]{knuth2014iskusstvo},
Макконнелл~\cite[\S3.4]{mcconnel2009analyz}.
\end{zztask}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput

Комментарии:
%
\begin{itemize}
\item 
\item 
\item Для справедливого сравнения при фиксированном размере различные алгоритмы следует применять к массивам с одинаковым содержимым.
\item Во избежание копирования кода организовать цикл по сортировкам с использованием массива указателей на функции (или структур, их содержащих).
\end{itemize}
