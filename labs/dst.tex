%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zztaskgroup{DST}{Динамические строки}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В задаче предлагается написать указанную в варианте функцию для обработки строк,
отвечающую заданному прототипу (при этом в самой функции исходные строки-аргументы
запрещается менять). Требуется использовать эту функцию в тестовой программе,
которая должна в цикле читать строки с клавиатуры и выдавать ответ на экран до
тех пор, пока пользователь не введет пустую строку (строку нулевой длины). 
Заданную функцию можно и \textbf{нужно} разбивать на более мелкие и понятные
подфункции, обеспечивая читаемость сложного алгоритма.\zztodo{Может вынести в комментарии? или вообще сделать линк на комментарии для STR}

В этом задании нельзя предполагать, что все вводимые строки имеют длину меньше
заранее оговоренной константы (пользователь всегда может ввести строку длиннее,
чем вы предполагаете). Для чтения строки и для результата надо использовать
динамический буфер и функции динамического распределения памяти (написать отдельную
функцию чтения строки заранее неизвестной длины \texttt{char* ReadLine(void)}).
Для чтения нельзя использовать опасную функцию \texttt{gets(s)},
как альтернатива есть \texttt{fgets()} или (более медленное) посимвольное чтение
через \texttt{getchar()}.\zztodo{я не понял, Readline читать до \\n или что?}

В некоторых задачах <<строки>> языка Си
могут содержать один или несколько символов \verb|'\n'|, то есть несколько
логических строк текста (абзац). Такие абзацы необходимо читать, склеивая
прочитанные логические строки, пока пользователь не обозначит пустую логическую
строку (нулевой длины), написав функцию \texttt{char* ReadParagraph(void)}).

Буквами договоримся считать прописные и строчные латинские буквы 
A--Z и a--z, словами --- последовательность букв и цифр 0--9. Все остальные
символы в строке будем считать разделителями слов. Подстрокой будем называть
произвольную часть строки.\zztodo{я бы добавил тут примеры, как в задаче STR}

В учебных целях при решении задач данного раздела функций стандартной
библиотеки, упрощающих работу со строками и символами (напр. из 
\texttt{<string.h>}), следует избегать, реализуя необходимую
функциональность самостоятельно.\zztodo{мне кажется, что тут стоит сразу написать, чтобы они могли заранее оценивать длину строки, хотя бы грубо, а потом реаллочить.}

Примеры диалога программы и пользователя:

\begin{zzoutput}
  Задание \thezztaskgroup-1: Выбор слов
  Введите строку: \zzuser{Hello, world!}
  Результат     : Hello, world
  Введите строку: \zzuser{int main(int argc, char* argv[]);}
  Результат     : int, main, int, argc, char, argv
  Введите строку: \zzuser{ }
\end{zzoutput}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zzsectionCOMMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\paragraph{Топик}
Мудрые слова на тему.

\begin{itemize}
    \item Поговорить о различиях между динамической памятью и стеком?
    \item Снова упомянуть о том, какие нужно функции делать, какие сущности выделять. Например, слова и тп. И как в соответствии с этим писать функции.
    \item + тут хотелось бы предупредить из самые распространенные ошибки и помимо говнокода. Например, кривое выделение, неправильная работа с указателями и тп.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zzsectionPLAN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{enumerate}
\item Сначала рекомендуется написать основную функцию программы --- обработку строки. Для простоты лучше передавать в нее строки, заданные в коде статически. Для написание функции необходимо определить и реализовать ее составные части, проверить их, а затем включить в основной алгоритм.
\item После написания основной функции нужно реализовать чтение строки и выделение памяти. Так как главная функция уже была написана и протестирована, то все ошибки можно будет локализовывать в новом коде. Кроме того, такой подход поможет лучше структурировать программу.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\zzsectionVARIATIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{zztask}[Выбор слов]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую слова исходной,
разделенные запятой и пробелом.\zztodo{я думаю, стоит сразу регламентировать, допускается ли запятая с пробелом после последнего слова.}
Например, из
<<\texttt{The good and the EVIL ones.}>>
должно получиться
<<\texttt{The, good, and, the, EVIL, ones}>>.

Прототип: \mintinline{c}|char* ExtractWords(char const* str);|
\end{zztask}

\begin{zztask}[Выбор уникальных слов]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую слова исходной без
повторений, разделенные запятой и пробелом.
Например, из
<<\texttt{The good and the EVIL ones.}>>
должно получиться
<<\texttt{The, good, and, EVIL, ones}>>.


Прототип: \mintinline{c}|char* UniqueWords(char const* str);|
\end{zztask}

\begin{zztask}[Выбор букв]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую буквы исходной (в том же
порядке), разделенные запятой и пробелом.
Например, из
<<\texttt{The evil.}>>
должно получиться
<<\texttt{T, h, e, e, v, i, l}>>.

Прототип: \mintinline{c}|char* ExtractLetters(char const* str);|
\end{zztask}

\begin{zztask}[Выбор уникальных букв]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую буквы исходной без
повторений (в том же порядке), разделенные запятой и пробелом.
Например, из
<<\texttt{The evil.}>>
должно получиться
<<\texttt{T, h, e, v, i, l}>>.

Прототип: \mintinline{c}|char* UniqueLetters(char const* str);|
\end{zztask}

\begin{zztask}[Поиск зеркальных подстрок]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую список без повторений всех
подстрок длиной больше одного символа, зеркальное отражение которых также
содержится в строке. Все разделители при этом следует игнорировать.\zztodo{Этот вариант я вообще не понял, что такое список? там через запятую с пробелом? и они должны быть макс длины, наверное?}
Например, из
<<\texttt{Ah, Satan sees Natasha!}>>
должно получиться
<<\texttt{AhSatansees}>>.\zztodo{Такое должно быть? Я вообще правильно понял?}

Прототип: \mintinline{c}|char* FindMirror(char const* str);|
\end{zztask}

\begin{zztask}[Упрощённый поиск по маске]
В рамках общего условия задачи написать функцию, которая по заданной строке
и строковой же <<маске>> создает в динамической памяти другую, содержащую список
всех слов исходной строки (через запятую), удовлетворяющих маске. Маска может
содержать буквы, цифры и ровно один знак \verb|'*'|, обозначающий совпадение с любой
последовательностью букв, в том числе и пустой (\verb|"c*p"| даёт совпадение с
\textit{cp, cap, clip, creep\dots}).

Прототип: \mintinline{c}|char* FindMaskWords(char const* str, char const* mask);|
\end{zztask}

\begin{zztask}[Поиск по маске]
В рамках общего условия задачи написать функцию, которая по заданной строке
и строковой же <<маске>> создает в динамической памяти другую, содержащую список
всех слов исходной строки (через запятую), удовлетворяющих маске. Маска может
содержать буквы, цифры и знаки \verb|'*'|, обозначающие совпадение с любой
последовательностью букв, в том числе и пустой (\verb|"c*p*"| даёт
\textit{cp, cap, clip, couple, champion\dots}).

Прототип: \mintinline{c}|char* FindMaskWords(char const* str, char const* mask);|
\end{zztask}

\begin{zztask}[Поиск цепочек]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую список новых слов (через
запятую), образованных по следующему правилу. Если одно слово исходной строки
заканчивается, а какое-то другое начинается с одинакового сочетания букв
(длины $> 1$), то эта пара образует новое слово результирующей строки
($\textit{table} + \textit{length} \rightarrow \textit{tablength}$).
Например, из
<<\texttt{This is the ordinary password}>>
должно получиться
<<\texttt{This, passwordinary}>>.

Прототип: \mintinline{c}|char* FindChains(char const* str);|
\end{zztask}

\begin{zztask}[Школоло строки]\zztodo{ПЛОХО ОПРЕДЕЛЁННАЯ ЗАДАЧА}
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую <<транслитерированную>>
строчку. В этой строке оригинальные русские буквы должны быть заменены на
школоло-последовательности ASCII символов, приблизительно похожих.

Пример:
\verb|AJIEIIIA| (<<Алёша>>), \verb|HAPyIIIuTEJIb 3AKOHA|
(<<нарушитель закона>>), \verb!>|<uBOTHOE! (<<животное>>).

Прототип: \mintinline{c}|char* ConvertShkololo(char const* str);|
\end{zztask}

\begin{zztask}[Транслитерация строк]
В рамках общего условия задачи написать функцию, которая по заданной строке
создает в динамической памяти другую, содержащую транслитерированную
строчку в соответствие со стандартами МИД РФ (\url{www.mid.ru}).
В этой строке оригинальные русские буквы должны быть заменены на
последовательности английских букв.\zztodo{Надо бы где-то написать, чтобы делали через табличку+ не выдумывали велосипед, а то был у меня тут один такой, сделал через 4 таблицы и кучу шлака.}

Пример:
\texttt{Alyosha} (<<Алёша>>), \texttt{narushitel{'} zakona}
(<<нарушитель закона>>), \texttt{zhivotnoye} (<<животное>>).

Прототип: \mintinline{c}|char* ConvertRussian(char const* str);|
\end{zztask}

\begin{zztask}[Перенос текста]
В рамках общего условия задачи написать функцию, которая по заданной строковой
переменной (возможно, содержащей несколько строк текста, разделенных символом
перевода строки \verb|'\n'|) создает в динамической памяти другую, содержащую
исходный текст, отформатированный в один абзац так, чтобы длина каждой
строки не превышала заданной ширины (вводится единожды в начале тестовой программы).
Несколько подряд идущих пробелов следует заменять одним пробелом.
Короткие строки надо дополнять словами со следующей строки, а слишком
длинные слова переносить целиком на следующую.
Например, для длины 10, из
<<\texttt{The abomination was                funny.}>>
должно получиться
<<\texttt{The \\abomination\\was funny.}>>.

Прототип: \mintinline{c}|char* FormatText(char const* str, int width);|
\end{zztask}

\begin{zztask}[Выравнивание текста]
В рамках общего условия задачи написать функцию, которая по заданной строковой
переменной (возможно, содержащей несколько строк текста, разделенных символом
перевода строки \verb|'\n'|) создает в динамической памяти другую, содержащую
исходный текст, отформатированный в один абзац так, чтобы длина каждой
строки была равна заданной ширине (вводится в начале тестовой программы).
Делать это надо за счет изменения числа подряд идущих пробелов. Слова
разбивать нельзя. Короткие строки надо дополнять словами со следующей
строки, а слишком длинные слова переносить целиком на следующую.\zztodo{Тут к условию много вопросов, могут ли пробелы быть в начале или конце строки? Если слова нельзя бить, то что делать, если они длиннее строки?}

Прототип: \mintinline{c}|char* JustifyText(char const* str, int width);|
\end{zztask}
