\newcounter{zzstyleicnt}[section]
\newcommand{\zzstyleitem}{\refstepcounter{zzstyleicnt}\paragraph{Пункт \arabic{section}.\thezzstyleicnt}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Стиль кодирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для того чтобы считаться хорошим программистом или хотя бы просто
человеком, умеющим программировать, недостаточно научиться писать
программы, <<хоть как-то>> (кое-как) решающие поставленную задачу.
Необходимо писать их \emph{качественно}, а это понятие традиционно
включает в себя выполнение некоторых требований, как к алгоритму, так и
к тексту программы. Следование определённым рекомендациям --- аккуратное
написание кода, выбор проверенных архитектурных и алгоритмических
решений --- позволяет уменьшить количество ошибок в программах и
упростить их поддержку. В конце концов, с коммерческой точки зрения это
удешевляет производство.

Здесь приводится ряд подобных инструкций, которые следует соблюдать при
написании лабораторных работ к курсу <<Алгоритмические языки>>. В данном
случае требования носят не рекомендательный, а обязательный характер.
Стилей кодирования (т.н. <<косметики>>) множество, каждый вариант имеет
свои достоинства и недостатки. Здесь не приводится аргументация в пользу
выбранных решений, а насильно вводится один из возможных вариантов,
чтобы приучить к самому понятию стиля и упростить преподавателям работу
по проверке программ.

Эти требования не являются требованиями на всю жизнь, они ограничены
настоящим курсом. В дальнейшем, в том числе и в профессиональной
деятельности, придется столкнуться с другими вариантами промышленных
стандартов кодирования (по-английски --- coding standard, coding style,
programming style\ldots{}), возможно сильно отличающимися или даже
противоречащими приведенному здесь. Необходимо будет научиться легко
переключаться между различными стандартами.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выравнивание}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\zzstyleitem
В одной строке может располагаться только одна команда.

\begin{minted}{c}
// так нельзя:
a = 5; b = sin(a);

// нужно так:
a = 5;
b = sin(a);
\end{minted}

\zzstyleitem

Запрещено объединять две команды в одну с помощью операции <<запятая>>
за исключением случаев, когда иначе не поступить.

\begin{minted}{c}
// так можно (иначе не поступить):
for (i = 0, j = 10; i < j; i++, j--)
  ...

// так нельзя:
if (c == 1)
  a = 5, b = sin(a);

// нужно так:
if (c == 1)
{
  a = 5;
  b = sin(a);
}
\end{minted}

\zzstyleitem

Тела составных команд (\texttt{while}, \texttt{do-while}, \texttt{for},
\texttt{if}, \texttt{switch}) и функций не должны располагаться на той
же строке, что и сама составная команда.

\begin{minted}{c}
// так нельзя:
if (x < 0) x = -x;

// нужно так:
if (x < 0)
  x = -x;

// так нельзя:
int even(int x) { return x % 2 == 0; }

// нужно так:
int even(int x)
{
  return x % 2 == 0;
}
\end{minted}

\zzstyleitem

Первые буквы всех команд одного уровня вложенности находятся в одной
колонке.

\begin{minted}{c}
// так нельзя:
 float g;
   g = sin(x);
return g;

// нужно так:
float g;
g = sin(x);
return g;
\end{minted}

\zzstyleitem

Тела составных команд и функций выделяются отступом ровно в 2 пробела по
отношению к родительской команде или заголовку функции. Использование
символов табуляции для отступов запрещено, необходимо корректно
установить настройки редактора или среды разработки.

\begin{minted}{c}
// так нельзя:
void f(int* x)
{
for (i = 1; i < 5; i++)
for (j = 1; j < 5; j++)
*(x++) = i - j;
}

// нужно так:
void f(int* x)
{
  for (i = 1; i < 5; i++)
    for (j = 1; j < 5; j++)
      *(x++) = i - j;
}
\end{minted}

\zzstyleitem

Длинные строки (\textgreater{}80 символов) должны разбиваться в
логически обоснованных местах на несколько строк, при этом продолжения
выделяются отступом в 4 пробела вместо двух.

\zzstyleitem

Метки \texttt{case} выравниваются по той же колонке что и команда
\texttt{switch}.

\begin{minted}{c}
// нужно так:
switch (a)
{
case 1:
  b = c * 2;
  break;
case 2:
  b = c * c + 3;
  break;
}
\end{minted}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Фигурные скобки}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\zzstyleitem

Фигурные скобки, выделяющие тело функции или составной команды,
располагаются каждая на отдельной строке, в одной колонке с началом
заголовка функции или команды, ровно одна под другой.

\begin{minted}{c}
// так нельзя:
int square(int x) {
  return x * x; 
}

// нужно так:
int square(int x)
{
  return x * x;
}

// так нельзя:
while (n > 1)
  {
    res *= n--;
  }

// нужно так:
while (n > 1)
{
  res *= n--;
}
\end{minted}

\zzstyleitem

Фигурные скобки, выделяющие тело команды \texttt{do-while},
располагаются одна под другой в той же колонке, что и слово \texttt{do}.
Слово \texttt{while} помещается на одной строке с закрывающей фигурной
скобкой, отделяясь от нее одним пробелом.

\begin{minted}{c}
// так нельзя:
do
{
  ...
}
while (i > 0);

// нужно так:
do
{
  ...
} while (i > 0);
\end{minted}

\zzstyleitem

Фигурные скобки внутри \texttt{case} не используются, если только нет
необходимости в локальных для блока переменных, но и таких случаев лучше
избегать.

\begin{minted}{c}
// так нельзя:
switch (a)
{
case 1:
  {
    b = c * 2;
    break;
  }
case 2:
  {
    b = c * c + 3;
    break;
  }
}
\end{minted}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Пробелы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\zzstyleitem

Знаки унарных операций прижимаются к своему единственному аргументу
(пробел отсутствует): \texttt{-5}, \texttt{n++}, \texttt{\&count}.

\zzstyleitem

Знаки бинарных операций отделяются от обоих своих аргументов одним
пробелом (слева и справа): \texttt{a\ +\ b}, \texttt{count\ =\ 3},
\texttt{x\ \textgreater{}=\ 0}.

\zzstyleitem

Круглые и квадратные скобки в выражениях прижимаются и к внутреннему
содержимому, и к внешнему аргументу: \texttt{sin(x)}, \texttt{a{[}5{]}}.

\zzstyleitem

Круглые скобки в командах \texttt{if}, \texttt{while}, \texttt{for},
\texttt{switch} и т.д. отделяются от самих операторов одним пробелом,
прижимаясь к содержимому. Круглые скобки в команде \texttt{return} не
ставятся: \texttt{if\ (a\ \textless{}\ 0)}, \texttt{switch\ (bitCount)},
\texttt{return\ a\ +\ b}.

\zzstyleitem

Знаки пунктуации \texttt{,} и \texttt{;} (запятая и точка с запятой) в
списках параметров, в описаниях переменных, в заголовке цикла
\texttt{for} прижимаются влево, а от правой части отделяются одним
пробелом: \texttt{float\ a,\ b,\ c;},
\texttt{for\ (i\ =\ 0;\ i\ \textless{}\ 5;\ i++)}.

\zzstyleitem

Операция \texttt{,} (запятая) как и знак пунктуации прижимается к левому
аргументу и отделяется от правого одним пробелом:
\texttt{i\ =\ 5,\ j\ =\ 0}.

\zzstyleitem

Операции \texttt{.} и \texttt{-\textgreater{}} (доступ к членам структур
и объединений) не выделяются пробелами, прижимаясь к обоим аргументам:
\texttt{pos.x}, \texttt{block-\textgreater{}address}.

\zzstyleitem

Оба знака операции \texttt{?:} отделяются от своих трех аргументов
пробелами с обеих сторон:
\texttt{minimum\ =\ a\ \textless{}\ b\ ?\ a\ :\ b}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Имена}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\zzstyleitem

Идентификаторы, используемые в программах для именования переменных,
функций, типов, макроопределений (\texttt{\#define}) и других элементов
языка должны составляться из слов английского языка, возможно с
сокращениями.

\zzstyleitem

Идентификаторы должны быть понятными, отражающими сущность именуемого
объекта. Имена \verb|kkk|, \verb|z3|, \verb|m| в общем случае таковыми не
являются и только затрудняют чтение кода. Использование \verb|i|, \verb|j|,
\verb|k| в качестве переменной цикла \texttt{for} может быть оправданным,
но в 99\% случаев можно и нужно придумать более говорящее имя даже им.

\zzstyleitem

Локальные переменные именуются по следующему правилу: имя составляется
из маленьких букв без использования знаков подчеркивания, каждое слово,
начиная со второго, пишется с большой буквы. Примеры: \texttt{message}
(<<сообщение>>), \texttt{wordCount} (<<счетчик слов>>), \texttt{found}
(<<найден>>),

\zzstyleitem

Функции именуются по следующему правилу: имя составляется из маленьких
букв без использования знаков подчеркивания, каждое слово пишется с
большой буквы: \texttt{AppendString()} (<<присоединить строку>>),
\texttt{VectorLength()} (<<длина вектора>>).

\zzstyleitem

В библиотечных модулях и больших программах из нескольких файлов
локальные для файла функции определяются с ключевым словом
\texttt{static}, начинаются с подчёркивания и маленькой буквы. Слова,
начиная со второго, по-прежнему пишутся с большой буквы:
\texttt{\_doSomeJob()}.

\zzstyleitem

Глобальные для всей программы переменные предваряются префиксом
\texttt{g\_}. Пример: \texttt{g\_fatalMessage}.

\zzstyleitem

Локальные для файла, но глобальные по отношению к функциям данного
модуля (т.е., \texttt{static}) переменные предваряются префиксом
\texttt{s\_}. Пример: \linebreak \texttt{s\_wordCount}.

\zzstyleitem

Типы именуются маленькими буквами, отдельные слова разделяются знаками
подчеркивания, добавляется окончание \texttt{\_t}. К типам относятся
идентификаторы, определенные с использованием ключевого слова
\texttt{typedef} через базовые простые или сложные типы --- структуры
(\texttt{struct}), объединения (\texttt{union}) и перечисления
(\texttt{enum}). Теги структур, объединений и перечислений строятся по
тому же принципу, благо, различие пространств имен позволяет. Примеры
имен: \texttt{vector\_t} (<<вектор>>), \texttt{memory\_block\_t} (<<блок
памяти>>), \texttt{block\_state\_t} (<<состояние блока>>).

\begin{minted}{c}
// нужно так:
typedef struct list_element_t
{
  int id;
  block_type_t type;
  struct list_element_t* next;
} list_element_t;
\end{minted}

\zzstyleitem

Имена значений перечисления записываются большими буквами, отдельные
слова разделяются знаками подчеркивания. Имена должны начинаться со
слова, описывающего принадлежность данной константы к конкретному
перечислению (содержать имя перечисления или его сокращение).

\begin{minted}{c}
// нужно так:
typedef enum
{
  BLOCKSTATE_FREE = 0,
  BLOCKSTATE_OCCUPIED = 1,
  BLOCKSTATE_ILLEGAL = -1,
} block_state_t;
\end{minted}

\zzstyleitem

Макроопределения именуются большими буквами, отдельные слова разделяются
знаками подчеркивания. Примеры имен: \texttt{MAX\_WORD\_LENGTH}
(<<максимальная длина слова>>), \texttt{CHECK\_VALUE(x)} (<<проверить
значение>>),


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Комментарии}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\zzstyleitem

Для пояснения того, что делает код, необходимо писать Комментарии ---
для других людей, которые будут читать вашу программу, для себя самого,
чтобы через пару лет (или недель), вернувшись к написанному, можно было
понять как это работает и что делает.

\zzstyleitem

Комментарии пишутся на понятном английском (в очень крайнем случае ---
русском) языке, с использованием обычных предложений (а не конструкций
языка программирования или псевдокода).

\zzstyleitem

В программах на Си для удобства разрешены однострочные Си++ Комментарии,
начинающиеся с \texttt{//}.

\zzstyleitem

В хорошо документированном коде должна встречаться одна строчка
Комментария на каждые 5--10 строк кода (обычно это --- логически
связанный блок кода, выполняющий одну задачу). Также коментируются все
функции, типы и глобальные (\texttt{extern}, \texttt{static})
переменные.

\zzstyleitem

Комментарий такого вида должен объяснять не столько \textbf{как} что-то
делается, сколько \textbf{что} (очень краткая сводка блока кода),
\textbf{для чего} и \textbf{почему так} делается (если решение может
показаться кому-либо неочевидным или даже неверным).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Оформление файлов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\zzstyleitem

Программы на Си пишутся в файлах с расширением \textbf{.c} (не .cpp),
заголовочные файлы имеют расширение \textbf{.h}.

\zzstyleitem

Заголовочные файлы содержат только описания макроопределений, типов,
прототипы глобальных функций, жизненно необходимых для использования
этого модуля, и \textbf{не содержат} исполняемого кода.

\zzstyleitem

Каждый h-файл должен обрамляться директивами препроцессора, исключающими
его повторное включение. Идентификатор, используемый в этих директивах,
необходимо образовывать из имени файла, записывая его большими буквами,
заменяя точку на знак подчеркивания и добавляя слово INCLUDED и два
знака подчеркивания в конце: \texttt{MYVECTOR\_H\_INCLUDED\_\_} для
файла \texttt{myvector.h}. Для компиляторов, её поддерживающих,
добавляется директива \texttt{\#pragma\ once}:

\begin{minted}{c}
#ifndef MYVECTOR_H_INCLUDED__
#define MYVECTOR_H_INCLUDED__
#pragma once

...

#endif // MYVECTOR_H_INCLUDED__
\end{minted}

\zzstyleitem

Каждая глобальная функция (вызывающаяся из другого модуля) должна иметь
прототип, описанный в h-файле с тем же именем, что и с-файл, содержащий
тело функции. Этот c-файл обязан содержать директиву \texttt{\#include},
включающую h-файл с прототипами описанных функций.

\zzstyleitem

Описания и определения обычно должны идти в следующем порядке:
подключение стандартных и собственных h-файлов, макроопределения,
описания типов, определения глобальных переменных, объявления
(прототипы) статических функций при необходимости, а затем определения
функций.
